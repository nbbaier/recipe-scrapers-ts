/**
 * Abstract base class for all recipe scrapers
 *
 * This class defines the interface that all recipe scrapers must implement.
 * It provides common functionality and delegates recipe extraction to
 * Schema.org and OpenGraph parsers.
 */

import * as cheerio from 'cheerio';
import { SchemaOrg } from '../parsers/schema-org';
import { OpenGraph } from '../parsers/opengraph';
import { ElementNotFoundInHtml } from '../exceptions';
import type { Recipe, IngredientGroup } from '../types/recipe';

/**
 * Abstract base scraper class
 */
export abstract class AbstractScraper {
  protected pageData: string;
  protected url: string;
  protected readonly $: cheerio.CheerioAPI;
  protected opengraph: OpenGraph;
  protected schema: SchemaOrg;

  /**
   * Creates a new scraper instance
   *
   * @param html - HTML content of the recipe page
   * @param url - URL of the recipe page
   */
  constructor(html: string, url: string) {
    this.pageData = html;
    this.url = url;
    this.$ = cheerio.load(html) as cheerio.CheerioAPI;
    this.opengraph = new OpenGraph(html);
    this.schema = new SchemaOrg(html);
  }

  /**
   * Returns the host domain for this scraper
   * Must be implemented by each site-specific scraper
   */
  abstract host(): string;

  /**
   * Extracts the recipe author
   */
  abstract author(): string | undefined;

  /**
   * Extracts the site name
   */
  abstract siteName(): string;

  /**
   * Extracts the recipe title
   */
  abstract title(): string;

  /**
   * Extracts the recipe category
   */
  abstract category(): string | undefined;

  /**
   * Extracts the recipe yields/servings
   */
  abstract yields(): string;

  /**
   * Extracts the recipe description
   */
  abstract description(): string;

  /**
   * Extracts the recipe ingredients
   */
  abstract ingredients(): string[];

  /**
   * Extracts the recipe instructions as a single string
   */
  abstract instructions(): string;

  /**
   * Extracts total time in minutes
   */
  abstract totalTime(): number | null;

  /**
   * Extracts cook time in minutes
   */
  abstract cookTime(): number | null;

  /**
   * Extracts prep time in minutes
   */
  abstract prepTime(): number | null;

  /**
   * Extracts recipe ratings
   */
  abstract ratings(): number | null;

  /**
   * Extracts ratings count
   */
  abstract ratingsCount(): number | null;

  /**
   * Extracts cuisine type
   */
  abstract cuisine(): string;

  /**
   * Extracts cooking method
   */
  abstract cookingMethod(): string;

  /**
   * Extracts recipe image URL
   */
  abstract image(): string;

  /**
   * Extracts keywords/tags
   */
  abstract keywords(): string[];

  /**
   * Extracts dietary restrictions
   */
  abstract dietaryRestrictions(): string[];

  /**
   * Extracts nutrition information
   */
  abstract nutrients(): Record<string, string>;

  /**
   * Extracts equipment needed
   */
  abstract equipment(): string[];

  /**
   * Extracts the canonical URL of the recipe
   * This implementation looks for a canonical link tag, falling back to the provided URL
   */
  canonicalUrl(): string {
    const canonicalLink = this.$('link[rel="canonical"][href]');
    if (canonicalLink.length > 0) {
      const href = canonicalLink.attr('href');
      if (href) {
        // Convert relative URLs to absolute
        try {
          const absolute = new URL(href, this.url);
          return absolute.href;
        } catch {
          return href;
        }
      }
    }
    return this.url;
  }

  /**
   * Extracts the language the recipe is written in
   * Checks html lang attribute and meta tags
   */
  language(): string {
    const candidateLanguages: string[] = [];

    // Check html lang attribute
    const htmlLang = this.$('html').attr('lang');
    if (htmlLang) {
      candidateLanguages.push(htmlLang);
    }

    // Check deprecated meta http-equiv content-language
    const metaLanguage = this.$(
      'meta[http-equiv="content-language"][content], meta[http-equiv="Content-Language"][content]'
    );
    if (metaLanguage.length > 0) {
      const content = metaLanguage.attr('content');
      if (content) {
        const language = content.split(',')[0].trim();
        if (language) {
          candidateLanguages.push(language);
        }
      }
    }

    // If multiple languages exist, remove 'en' (commonly generated by HTML editors)
    if (candidateLanguages.length > 1) {
      const filteredLanguages = candidateLanguages.filter((lang) => lang !== 'en');
      if (filteredLanguages.length > 0) {
        return filteredLanguages[0];
      }
    }

    // Return the first candidate language
    if (candidateLanguages.length > 0) {
      return candidateLanguages[0];
    }

    throw new ElementNotFoundInHtml('Could not find language.');
  }

  /**
   * Extracts recipe instructions as a list of steps
   * Splits the instructions string by newlines
   */
  instructionsList(): string[] {
    return this.instructions()
      .split('\n')
      .filter((instruction) => instruction.trim() !== '');
  }

  /**
   * Extracts ingredient groups (ingredients organized by purpose/section)
   * For now, returns a single group with all ingredients
   * TODO: Implement proper ingredient grouping logic
   */
  ingredientGroups(): IngredientGroup[] {
    return [
      {
        purpose: undefined,
        ingredients: this.ingredients(),
      },
    ];
  }

  /**
   * Extracts all links found in the recipe
   */
  links(): Array<Record<string, string>> {
    const invalidHref = new Set(['#', '']);
    const links: Array<Record<string, string>> = [];

    this.$('a[href]').each((_, element) => {
      const $link = this.$(element);
      const href = $link.attr('href');

      if (href && !invalidHref.has(href)) {
        const attrs: Record<string, string> = {};
        // Get all attributes from the element
        const elementAttrs = $link.attr();
        if (elementAttrs) {
          for (const [key, value] of Object.entries(elementAttrs)) {
            if (typeof value === 'string') {
              attrs[key] = value;
            }
          }
        }
        links.push(attrs);
      }
    });

    return links;
  }

  /**
   * Converts the recipe to JSON format
   * Calls all public methods and catches exceptions for missing data
   */
  // Type for public method names of AbstractScraper that return any value (excluding constructor and properties)
  private static readonly scraperMethodNames = [
    'host',
    'canonicalUrl',
    'language',
    'author',
    'siteName',
    'title',
    'category',
    'yields',
    'description',
    'ingredients',
    'ingredientGroups',
    'instructions',
    'instructionsList',
    'totalTime',
    'cookTime',
    'prepTime',
    'ratings',
    'ratingsCount',
    'cuisine',
    'cookingMethod',
    'image',
    'keywords',
    'dietaryRestrictions',
    'nutrients',
    'equipment',
  ] as const;

  toJson(): Partial<Recipe> {
    // Use Record<string, unknown> for type-safe dynamic property assignment
    const jsonDict: Record<string, unknown> = {};

    // List of methods to call (excluding internal methods)
    const methodsToCall: readonly string[] = AbstractScraper.scraperMethodNames;

    for (const method of methodsToCall) {
      try {
        const func = this[method as keyof this];
        if (typeof func === 'function') {
          const result = (func as () => unknown).call(this);

          // Map method names to Recipe field names
          const fieldName = this.mapMethodToField(method as keyof AbstractScraper);
          jsonDict[fieldName] = result;
        }
      } catch (error) {
        // Skip fields that throw exceptions (data not available)
      }
    }

    // Safe to cast since we control the method names and field mappings
    return jsonDict as Partial<Recipe>;
  }

  /**
   * Maps method names to Recipe field names
   * Handles camelCase conversion
   */
  private mapMethodToField(method: keyof AbstractScraper): string {
    // Convert method names to match Recipe interface
    const mapping: Record<string, string> = {
      siteName: 'site_name',
      canonicalUrl: 'canonical_url',
      ingredientGroups: 'ingredient_groups',
      instructionsList: 'instructions_list',
      totalTime: 'total_time',
      cookTime: 'cook_time',
      prepTime: 'prep_time',
      ratingsCount: 'ratings_count',
      cookingMethod: 'cooking_method',
      dietaryRestrictions: 'dietary_restrictions',
    };

    return mapping[method] || method;
  }
}
